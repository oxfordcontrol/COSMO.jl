<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Performance Tips · COSMO.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-134239283-1', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://oxfordcontrol.github.io/COSMO.jl/stable/performance/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><script src="../assets/github_buttons.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="COSMO.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">COSMO.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../jump/">JuMP Interface</a></li><li><a class="tocitem" href="../lin_solver/">Linear System Solver</a></li><li><a class="tocitem" href="../acceleration/">Acceleration</a></li><li><a class="tocitem" href="../literate/build/custom_cone/">Custom Cone Constraint</a></li><li><a class="tocitem" href="../decomposition/">Chordal Decomposition</a></li><li><a class="tocitem" href="../literate/build/portfolio_model_updates/">Model Updates</a></li><li><a class="tocitem" href="../literate/build/arbitrary_precision/">Arbitrary Precision</a></li><li class="is-active"><a class="tocitem" href>Performance Tips</a><ul class="internal"><li><a class="tocitem" href="#First-run"><span>First run</span></a></li><li><a class="tocitem" href="#Solver-Timings"><span>Solver Timings</span></a></li><li><a class="tocitem" href="#Convergence"><span>Convergence</span></a></li><li><a class="tocitem" href="#Computational-performance"><span>Computational performance</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../method/">Method</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/closest_correlation_matrix/">Closest Correlation Matrix</a></li><li><a class="tocitem" href="../examples/logistic_regression/">Logistic Regression</a></li><li><a class="tocitem" href="../examples/lovasz_petersen/">Lovász Theta Function</a></li><li><a class="tocitem" href="../examples/lp/">Linear Program</a></li><li><a class="tocitem" href="../examples/maxcut/">Maximum Cut Problem</a></li><li><a class="tocitem" href="../examples/portfolio_optimisation/">Portfolio Optimisation</a></li><li><a class="tocitem" href="../examples/qp/">Quadratic Program</a></li><li><a class="tocitem" href="../examples/sum_abs_k_eigenvalues/">Minimizing the sum of the k-largest λ</a></li><li><a class="tocitem" href="../examples/svm_primal/">Support Vector Machine</a></li><li><a class="tocitem" href="../examples/two_way_partitioning/">Relaxed Two-Way Partitioning Problem</a></li></ul></li><li><a class="tocitem" href="../citing/">Citing COSMO</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Performance Tips</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Performance Tips</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oxfordcontrol/COSMO.jl/blob/master/docs/src/performance.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Performance-Tips"><a class="docs-heading-anchor" href="#Performance-Tips">Performance Tips</a><a id="Performance-Tips-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Tips" title="Permalink"></a></h1><p>There are a number of ways to improve the performance of the solver given a particular problem. If you are not satisfied with the performance there are a number of things you have to determine first. Is the solver slow because</p><ul><li>it&#39;s the first time you ran it in the current Julia session or</li><li>is it because the solver needs a lot of iterations (convergence) or</li><li>is each iteration or the initial factorisation slow (computational performance)?</li></ul><p>Let&#39;s see how each point can be addressed.</p><h2 id="First-run"><a class="docs-heading-anchor" href="#First-run">First run</a><a id="First-run-1"></a><a class="docs-heading-anchor-permalink" href="#First-run" title="Permalink"></a></h2><p>Whenever a new Julia session is started, the first run will trigger a compilation of all functions based on their arguments used in your script. This will slow the first execution of COSMO down. After that Julia will call the fast compiled functions. To get around this, you can either keep your current Julia session open and discard the first run. Alternatively, if your problem is very large, you could solve a small version of your problem first to trigger the compilation. Another option is to use <a href="https://github.com/JuliaLang/PackageCompiler.jl">PackageCompiler</a> to save compiled functions into a <em>sysimage</em> that can be loaded at startup.</p><h2 id="Solver-Timings"><a class="docs-heading-anchor" href="#Solver-Timings">Solver Timings</a><a id="Solver-Timings-1"></a><a class="docs-heading-anchor-permalink" href="#Solver-Timings" title="Permalink"></a></h2><p>It is often instructive to look at the detailed solver timing results for your problem. This can reveal where most of the time is spent. To achieve this, run COSMO with the setting <code>verbose_timing = true</code>. After solving the problem with <code>result = COSMO.optimize!(model)</code> you can look at <code>result.times</code> for a breakdown of the times spent in different parts of the algorithm, see <a href="../getting_started/#Timings">Timings</a> for more details. Especially take a look at the ratio of factorisation time and iteration time. If you use <code>JuMP</code> to solve the problem, you can take a look at the timings with <code>backend(model).optimizer.model.optimizer.results.times</code>.</p><h2 id="Convergence"><a class="docs-heading-anchor" href="#Convergence">Convergence</a><a id="Convergence-1"></a><a class="docs-heading-anchor-permalink" href="#Convergence" title="Permalink"></a></h2><p>It is possible that COSMO converges slowly, i.e. needs a large number of iterations, for your problem given its default parameters.</p><h3 id="Parameters"><a class="docs-heading-anchor" href="#Parameters">Parameters</a><a id="Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Parameters" title="Permalink"></a></h3><p>You could try changing any of the following parameters:</p><ul><li><code>rho</code>: The initial algorithm step parameter has a large influence on the convergence. Try different values between <code>1e-5</code> and <code>10</code>.</li><li><code>adaptive_rho = false</code>: You can try to disable the automatic rho adaption and use different rho values.</li><li><code>adaptive_rho_interval</code>: This specifies after how many iterations COSMO tries to adapt the rho parameter. You can also set <code>adaptive_rho_interval = 0</code> which adapts the rho parameter after the time spent iterating passes 40% of the factorisation time. This is currently the default in <a href="https://osqp.org/">OSQP</a> and works well with QPs.</li><li><code>alpha = 1.0</code>: This disables the over-relaxation that is used in the algorithm. We recommend values between <code>1.0 - 1.6</code>.</li><li><code>scaling = 0</code>: This disables the problem scaling.</li><li><code>eps_abs</code> and <code>eps_rel</code>: Check the impact of modifying the stopping accuracies.</li></ul><h3 id="Use-warm-starting"><a class="docs-heading-anchor" href="#Use-warm-starting">Use warm starting</a><a id="Use-warm-starting-1"></a><a class="docs-heading-anchor-permalink" href="#Use-warm-starting" title="Permalink"></a></h3><p>The number of iterations can be dramatically decreased by providing a good initial guess for <code>x</code>, <code>s</code> and <code>y</code>. Examples where warm starting is commonly used are model predictive control and portfolio backtests, see <a href="../getting_started/#Warm-starting">Warm starting</a>.</p><h2 id="Computational-performance"><a class="docs-heading-anchor" href="#Computational-performance">Computational performance</a><a id="Computational-performance-1"></a><a class="docs-heading-anchor-permalink" href="#Computational-performance" title="Permalink"></a></h2><p>If the convergence of the algorithm is not an issue, there are still a number of steps you can take to make COSMO faster.</p><h3 id="Intel-MKL-BLAS/LAPACK"><a class="docs-heading-anchor" href="#Intel-MKL-BLAS/LAPACK">Intel MKL BLAS/LAPACK</a><a id="Intel-MKL-BLAS/LAPACK-1"></a><a class="docs-heading-anchor-permalink" href="#Intel-MKL-BLAS/LAPACK" title="Permalink"></a></h3><p>We experienced significant performance improvements on Intel CPUs if Julia is compiled with MKL BLAS. This is because Julia&#39;s linear algebra function will use Intel MKL BLAS and LAPACK functions that are optimised for Intel hardware. The effect is especially significant for SDPs because most of the time is spent in the LAPACK function <code>syevr</code>. If you are running Julia on Intel hardware, an easy way to compile Julia with MKL is to add and build the MKL package, see <a href="https://github.com/JuliaComputing/MKL.jl">MKL.jl</a>. To verify your current BLAS vendor you can use <code>julia&gt; LinearAlgebra.BLAS.vendor()</code>.</p><h3 id="Linear-system-solver"><a class="docs-heading-anchor" href="#Linear-system-solver">Linear system solver</a><a id="Linear-system-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-system-solver" title="Permalink"></a></h3><p>COSMO uses <code>QDLDL.jl</code> as the default linear system solver. In our experience this seems to be a competitive choice until about <code>1e5 - 1e6</code> nonzeros in the constraint matrix. After that it is worth trying one of the indirect system solvers, such as CG or MINRES. Furthermore, we also recommend trying Pardiso (or MKLPardiso) for problems of that dimension. More details can be found here: <a href="../lin_solver/#Linear-System-Solver">Linear System Solver</a>.</p><h3 id="Custom-cones"><a class="docs-heading-anchor" href="#Custom-cones">Custom cones</a><a id="Custom-cones-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-cones" title="Permalink"></a></h3><p>In some cases the computations can be speed-up if certain constraints in the problem allow the implementation of a fast projection function. We allow the user to define their own custom convex cone with a corresponding projection function. The custom cone has to be defined as <code>struct CustomCone{T} &lt;: COSMO.AbstractConvexSet{T}</code>. Furthermore, the user has to define a function that projects an input vector <code>x</code> onto the custom cone, i.e. <code>function COSMO.project!(x::AbstractVector{T}, C::CustomCone{T}) where {T} ... end</code>.</p><h3 id="Multithreading"><a class="docs-heading-anchor" href="#Multithreading">Multithreading</a><a id="Multithreading-1"></a><a class="docs-heading-anchor-permalink" href="#Multithreading" title="Permalink"></a></h3><p>COSMO allows the execution of the projection step for multiple constraints in parallel using Julia&#39;s multithreading features. This is currently not enabled in the tagged release because of stability issues in earlier Julia versions. To use multithreading checkout the branch <code>with_multi_threading</code>, which we keep in sync with the latest tagged release. This can be installed via Julia&#39;s package manager with  <code>pkg&gt; add COSMO#with_multi_threading</code>. Afterwards, before starting Julia, set <code>export JULIA_NUM_THREADS=[NUMBER_LOGICAL_CORES_HERE]</code>. In Julia you can verify the number of threads with <code>julia&gt; Threads.nthreads()</code>.</p><p>Notice that the extra overhead for multithreading can slow the solver down if the problem is small. However, we noticed significant performance improvements if the problem contained multiple positive semidefinite constraints or when one large constraint was decomposed. In that case it also helps to restrict the number of BLAS threads per Julia thread with <code>julia&gt; BLAS.set_num_threads(1)</code> to prevent oversubscription of the available cores.</p><p>Multithreading can also be used in the factorisation step if the Pardiso or MKLPardiso solver are selected. This is only advisable for constraint matrices with more than <code>1e5</code> nonzeros.</p><h3 id="Chordal-decomposition-and-Clique-merging"><a class="docs-heading-anchor" href="#Chordal-decomposition-and-Clique-merging">Chordal decomposition and Clique merging</a><a id="Chordal-decomposition-and-Clique-merging-1"></a><a class="docs-heading-anchor-permalink" href="#Chordal-decomposition-and-Clique-merging" title="Permalink"></a></h3><p>When solving large structured and sparse SDPs significant performance improvements are achievable if the problem is passed to COSMO in the right way. This means the solver has to be able to infer the structure of the positive semidefinite variable from the constraint. See the section on <a href="../decomposition/#Chordal-Decomposition">Chordal Decomposition</a> for more details. In some cases the primal SDP doesn&#39;t allow decomposition but the dual SDP does, consider the <a href="../examples/maxcut/#Maximum-Cut-Problem">Maximum Cut Problem</a> and the <a href="../examples/two_way_partitioning/#Relaxed-Two-Way-Partitioning-Problem">Relaxed Two-Way Partitioning Problem</a> for examples.</p><p>If the problem is decomposable it is also worth experimenting with different clique merging strategies to see how they impact the performance. More details can be found here: <a href="../decomposition/#Clique-merging">Clique merging</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../literate/build/arbitrary_precision/">« Arbitrary Precision</a><a class="docs-footer-nextpage" href="../method/">Method »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 22 April 2021 07:35">Thursday 22 April 2021</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
