<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Chordal Decomposition · COSMO.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-134239283-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-134239283-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://oxfordcontrol.github.io/COSMO.jl/stable/decomposition/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><script src="../assets/github_buttons.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="COSMO.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">COSMO.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../jump/">JuMP Interface</a></li><li><a class="tocitem" href="../lin_solver/">Linear System Solver</a></li><li><a class="tocitem" href="../acceleration/">Acceleration</a></li><li><a class="tocitem" href="../literate/build/custom_cone/">Custom Cone Constraint</a></li><li class="is-active"><a class="tocitem" href>Chordal Decomposition</a><ul class="internal"><li><a class="tocitem" href="#Example-problem"><span>Example problem</span></a></li><li><a class="tocitem" href="#Clique-merging"><span>Clique merging</span></a></li><li><a class="tocitem" href="#Completing-the-dual-variable"><span>Completing the dual variable</span></a></li></ul></li><li><a class="tocitem" href="../literate/build/portfolio_model_updates/">Model Updates</a></li><li><a class="tocitem" href="../literate/build/arbitrary_precision/">Arbitrary Precision</a></li><li><a class="tocitem" href="../performance/">Performance Tips</a></li></ul></li><li><a class="tocitem" href="../method/">Method</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/closest_correlation_matrix/">Closest Correlation Matrix</a></li><li><a class="tocitem" href="../examples/logistic_regression/">Logistic Regression</a></li><li><a class="tocitem" href="../examples/lovasz_petersen/">Lovász Theta Function</a></li><li><a class="tocitem" href="../examples/lp/">Linear Program</a></li><li><a class="tocitem" href="../examples/maxcut/">Maximum Cut Problem</a></li><li><a class="tocitem" href="../examples/portfolio_optimisation/">Portfolio Optimisation</a></li><li><a class="tocitem" href="../examples/qp/">Quadratic Program</a></li><li><a class="tocitem" href="../examples/sum_abs_k_eigenvalues/">Minimizing the sum of the k-largest λ</a></li><li><a class="tocitem" href="../examples/svm_primal/">Support Vector Machine</a></li><li><a class="tocitem" href="../examples/two_way_partitioning/">Relaxed Two-Way Partitioning Problem</a></li></ul></li><li><a class="tocitem" href="../citing/">Citing COSMO</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Chordal Decomposition</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Chordal Decomposition</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oxfordcontrol/COSMO.jl/blob/master/docs/src/decomposition.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Chordal-Decomposition"><a class="docs-heading-anchor" href="#Chordal-Decomposition">Chordal Decomposition</a><a id="Chordal-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Chordal-Decomposition" title="Permalink"></a></h1><p>For very large sparse semidefinite programs (SDPs) it is often helpful to analyse the sparsity structure of the PSD constraint(s). If the equality constraints impose a sparsity structure on the matrix variable, one PSD constraint on a large matrix variable can be decomposed into several smaller constraints. This results usually in a significant speedup and reduction in solve time.</p><p>The following example gives a short overview on chordal decomposition and clique merging. For more details, take a look at our <a href="https://arxiv.org/abs/1911.05615">paper</a> on clique merging or watch the corresponding <a href="https://vimeo.com/439962112">presentation</a> that I gave on the topic.</p><h2 id="Example-problem"><a class="docs-heading-anchor" href="#Example-problem">Example problem</a><a id="Example-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Example-problem" title="Permalink"></a></h2><p>Let&#39;s consider the following SDP in standard dual form:</p><p class="math-container">\[\begin{array}{ll}
 \text{minimize} &amp; c^\top x \\
  \text{subject to} &amp;\displaystyle \sum_{i=1}^m A_i x_i + S = B\\
                  &amp; S \in \mathbb{S}^n_+,
\end{array}\]</p><p>with problem data matrices <span>$A_1, \ldots, A_m, B \in \mathbb{S}^n$</span>, vector variable <span>$x \in \mathbb{R}^n$</span>, and matrix variable  <span>$S \in \mathbb{S}^n_+$</span>.</p><p>Let&#39;s look at the following example problem with <span>$m=2$</span> and  <span>$n=9$</span>:</p><pre><code class="language-julia hljs">A1 = [-4.0 0.0 -2.0 0.0 0.0 -1.0 0.0 0.0 0.0; 0.0 -3.0 -1.0 0.0 0.0 0.0 0.0 0.0 0.0; -2.0 -1.0 -2.0 0.0 0.0 5.0 4.0 -4.0 0.0; 0.0 0.0 0.0 -4.0 -5.0 0.0 0.0 3.0 0.0; 0.0 0.0 0.0 -5.0 4.0 0.0 0.0 2.0 0.0; -1.0 0.0 5.0 0.0 0.0 5.0 -4.0 -4.0 -5.0; 0.0 0.0 4.0 0.0 0.0 -4.0 -1.0 -1.0 -3.0; 0.0 0.0 -4.0 3.0 2.0 -4.0 -1.0 2.0 -2.0; 0.0 0.0 0.0 0.0 0.0 -5.0 -3.0 -2.0 -3.0];

A2 = [-5.0 0.0 3.0 0.0 0.0 -2.0 0.0 0.0 0.0; 0.0 -3.0 -5.0 0.0 0.0 0.0 0.0 0.0 0.0; 3.0 -5.0 3.0 0.0 0.0 5.0 -4.0 -5.0 0.0; 0.0 0.0 0.0 3.0 2.0 0.0 0.0 -2.0 0.0; 0.0 0.0 0.0 2.0 4.0 0.0 0.0 -3.0 0.0; -2.0 0.0 5.0 0.0 0.0 1.0 -5.0 -2.0 -4.0; 0.0 0.0 -4.0 0.0 0.0 -5.0 -2.0 -3.0 3.0; 0.0 0.0 -5.0 -2.0 -3.0 -2.0 -3.0 5.0 3.0; 0.0 0.0 0.0 0.0 0.0 -4.0 3.0 3.0 -4.0];

B = [-0.11477375644968069 0.0 6.739182490600791 0.0 0.0 -1.2185593245043502 0.0 0.0 0.0; 0.0 1.2827680528587497 -5.136452036888789 0.0 0.0 0.0 0.0 0.0 0.0; 6.739182490600791 -5.136452036888789 7.344770673489607 0.0 0.0 -0.2224400187044442 -10.505300166831221 -1.2627361794562273 0.0; 0.0 0.0 0.0 10.327710040060499 8.91534585379813 0.0 0.0 -6.525873789637007 0.0; 0.0 0.0 0.0 8.91534585379813 0.8370459338528677 0.0 0.0 -6.210900615408826 0.0; -1.2185593245043502 0.0 -0.2224400187044442 0.0 0.0 -3.8185953011245024 -0.994033914192722 2.8156077981712997 1.4524716674219218; 0.0 0.0 -10.505300166831221 0.0 0.0 -0.994033914192722 0.029162208619863517 -2.8123790276830745 7.663416446183705; 0.0 0.0 -1.2627361794562273 -6.525873789637007 -6.210900615408826 2.8156077981712997 -2.8123790276830745 4.71893305728242 6.322431630550857; 0.0 0.0 0.0 0.0 0.0 1.4524716674219218 7.663416446183705 6.322431630550857 0.5026094532322212];

c = [-0.21052661285686525, -1.263324575834677];</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 -0.21052661285686525
 -1.263324575834677</code></pre><p>Note that the data matrices <span>$A_1,\dots, A_m, B$</span> all have the same sparsity pattern (common zeros in certain entries). Take a look at <span>$A_1$</span>:</p><pre><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A1</code><code class="nohighlight hljs ansi" style="display:block;">9×9 Matrix{Float64}:
 -4.0   0.0  -2.0   0.0   0.0  -1.0   0.0   0.0   0.0
  0.0  -3.0  -1.0   0.0   0.0   0.0   0.0   0.0   0.0
 -2.0  -1.0  -2.0   0.0   0.0   5.0   4.0  -4.0   0.0
  0.0   0.0   0.0  -4.0  -5.0   0.0   0.0   3.0   0.0
  0.0   0.0   0.0  -5.0   4.0   0.0   0.0   2.0   0.0
 -1.0   0.0   5.0   0.0   0.0   5.0  -4.0  -4.0  -5.0
  0.0   0.0   4.0   0.0   0.0  -4.0  -1.0  -1.0  -3.0
  0.0   0.0  -4.0   3.0   2.0  -4.0  -1.0   2.0  -2.0
  0.0   0.0   0.0   0.0   0.0  -5.0  -3.0  -2.0  -3.0</code></pre><p>Since all the data matrices have zeros in the same places, the equality constraint of the problem tells us that our matrix variable <span>$S$</span> will also have zeros in these places. The <em>aggregated</em> pattern matrix of <span>$S$</span> is shown in the following figure, where a dot represents a nonzero entry:</p><p><img src="../assets/example_decomposition.gif" alt/></p><p>Since the matrices are symmetric we only show the lower triangle. We can represent the aggregated sparsity pattern of the problem using a graph <span>$G(V, E)$</span>, where the vertex set <span>$V$</span> is given by the column indices of the matrix and we introduce an edge <span>$(i,j) \in E$</span> for every nonzero matrix element <span>$S_{ij}$</span>. The graph for the example problem is shown in the right figure. In order to decompose the problem, we have to find the <em>cliques</em>, i.e. completely connected subgraphs, of the graph <span>$G$</span>. These cliques represent the dense subblocks of non-zero entries in the matrix (see the colored entries in the figure). In order for the theory to work, we also have to require <span>$G$</span> to be a <a href="https://en.wikipedia.org/wiki/Chordal_graph">chordal</a> graph. For the purpose of this example, we just assume that <span>$G$</span> is chordal and keep in mind that we can always make a graph chordal by adding more edges.</p><p><code>COSMO</code> finds the cliques of the graph automatically, if a constraint of type <code>COSMO.PsdCone</code> or <code>COSMO.PsdConeTriangle</code> is present in the problem and additional equality constraints impose a structure on them. For the example problem <code>COSMO</code> finds the following cliques: <span>$\mathcal{C_1}=\{1,3,6\}, \; \mathcal{C_2}=\{2,3\}, \; \mathcal{C_3}=\{3,6,7,8\}, \; \mathcal{C_4}=\{4,5,8\}$</span> and <span>$\mathcal{C_5}=\{6,7,8,9\}$</span>.</p><p>Let&#39;s denote the set of cliques <span>$\mathcal{B}=\{\mathcal{C}_1,\ldots,\mathcal{C_p}\}$</span>. To represent the relationship between different cliques, e.g. in terms of overlapping entries, it is helpful to represent them either as a clique tree <span>$\mathcal{T}(\mathcal{B}, \mathcal{E})$</span> (left) or a clique graph <span>$\mathcal{G}(\mathcal{B}, \xi)$</span> (right), shown in the following figures:</p><p><img src="../assets/example_tree.jpg" alt/> <img src="../assets/clique_graph.jpg" alt/></p><p>Once the cliques have been found, we can use the following theorem to decompose the problem (and speed up the solver significantly).</p><p><strong>Theorem</strong> (<em>Agler&#39;s Theorem</em>)</p><p>Let <span>$G(V,E)$</span> be a chordal graph with a set of maximal cliques <span>$\{\mathcal{C}_1,\ldots,\mathcal{C}_p \}$</span>. Then <span>$S \in \mathbb{S}^n_+(E,0)$</span> if and only if there exist matrices <span>$S_\ell \in S^{|\mathcal{C}_\ell|}$</span> for <span>$\ell = 1,\ldots,p$</span> such that</p><p class="math-container">\[S = \displaystyle \sum_{\ell = 1}^p T_\ell^\top S_\ell T_\ell,\]</p><p>where <span>$T_\ell$</span> is an entry-selector matrix that maps the subblocks <span>$S_\ell$</span> into the correct entries of the original matrix <span>$S$</span>.</p><p>In other words, instead of solving the original problem and choosing <span>$S$</span> to be positive semidefinite, we only have to choose the subblocks <span>$S_\ell$</span> of the matrix <span>$S$</span> to be positive semidefinite and make sure that the individual blocks &quot;add up&quot; to <span>$S$</span>. Thus, we can solve the equivalent problem:</p><p class="math-container">\[\begin{array}{ll}
 \text{minimize} &amp; c^\top x \\
  \text{subject to} &amp;\displaystyle \sum_{i=1}^m A_i x + \sum_{\ell = 1}^p T_l^\top S_\ell T_\ell = B\\
                  &amp; S_\ell \in \mathbb{S}^{|\mathcal{C}_\ell|}_+, \; l = 1, \ldots, p.
\end{array}\]</p><p>Compare this again with the problem at the top of the page. We have replaced the positive semidefinite constraint on the matrix variable <span>$S$</span> by <span>$p$</span> constraints on the smaller subblocks <span>$S_\ell$</span>. Why is this useful?</p><p>When solving an SDP, the major linear algebra operation is a projection onto the constraint set, see <a href="../method/#Method">Method</a>. This projection is done at each iteration of the algorithm and for positive semidefinite constraints involves an eigenvalue decomposition of the matrix iterate. Unfortunately, an eigenvalue decomposition of a matrix of dimension <span>$n$</span> has a complexity of roughly <span>$\mathcal{O}(n^3)$</span>.</p><p>For our example this means that we now project one <span>$2\times 2$</span> block, two <span>$3 \times 3$</span> blocks and two <span>$4 \times 4$</span> blocks instead of one <span>$9 \times 9$</span> block. For small problems, this doesn&#39;t seem to make much of a difference, but consider of a problem with 1000 <span>$11 \times 11$</span> blocks along the diagonal and overlapping by one entry. Taking into account that the computational cost scales cubicly, we can improve the performance of the solver by projecting 1000 <span>$11\times 11$</span> blocks instead of projecting one giant <span>$10001\times 10001$</span> block at each iteration.</p><p>Let&#39;s go back to our example and solve it with <code>COSMO</code> and <code>JuMP</code>:</p><pre><code class="language-julia hljs">model = JuMP.Model(with_optimizer(COSMO.Optimizer, decompose = true, merge_strategy = COSMO.NoMerge));
@variable(model, x[1:2]);
@objective(model, Min, c&#39; * x )
@constraint(model, Symmetric(B - A1  .* x[1] - A2 .* x[2] )  in JuMP.PSDCone());

JuMP.optimize!(model)</code></pre><p>Notice that we set the solver settings <code>decompose = true</code> to allow <code>COSMO</code> to decompose the problem. Furthermore, we set the clique merging strategy to <code>COSMO.NoMerge</code>. This just means that after we have found the cliques we don&#39;t attempt to merge some of them (more about clique merging below). We get the following output from the solver:</p><pre><code class="language-julia hljs">------------------------------------------------------------------
          COSMO v0.5.0 - A Quadratic Objective Conic Solver
                         Michael Garstka
                University of Oxford, 2017 - 2019
------------------------------------------------------------------

Problem:  x ∈ R^{13},
          constraints: A ∈ R^{35x13} (70 nnz),
          matrix size to factor: 48x48 (188 nnz)
Sets:     PsdConeTriangle of dim: 10
          PsdConeTriangle of dim: 10
          PsdConeTriangle of dim: 6
          PsdConeTriangle of dim: 6
          PsdConeTriangle of dim: 3
Decomp:   Num of original PSD cones: 1
          Num decomposable PSD cones: 1
          Num PSD cones after decomposition: 5
          Merge Strategy: NoMerge
Settings: ϵ_abs = 1.0e-04, ϵ_rel = 1.0e-04,
          ϵ_prim_inf = 1.0e-06, ϵ_dual_inf = 1.0e-04,
          ρ = 0.1, σ = 1.0e-6, α = 1.6,
          max_iter = 2500,
          scaling iter = 10 (on),
          check termination every 40 iter,
          check infeasibility every 40 iter,
          KKT system solver: QDLDL
Setup Time: 0.14ms

Iter:   Objective:  Primal Res: Dual Res:   Rho:
40  -1.4134e+00 1.2320e-05  3.0409e-05  1.0000e-01

------------------------------------------------------------------
&gt;&gt;&gt; Results
Status: Solved
Iterations: 40
Optimal objective: -1.4134
Runtime: 0.002s (1.93ms)</code></pre><p>Under <em>sets</em> we can indeed see that <code>COSMO</code> solved a problem with five PSD constraints corresponding to the cliques <span>$\mathcal{C}_1,\ldots, \mathcal{C}_5$</span> discovered in the sparsity pattern. (Note that the dimension printed is the number of entries in the upper triangle of the matrix block.)</p><h2 id="Clique-merging"><a class="docs-heading-anchor" href="#Clique-merging">Clique merging</a><a id="Clique-merging-1"></a><a class="docs-heading-anchor-permalink" href="#Clique-merging" title="Permalink"></a></h2><p>After we have found the cliques of the sparsity pattern, we are allowed to merge some of them back together. For the graph of the sparsity pattern this just means adding more edges or treating some <em>structural</em> zeros as <em>numerical</em> zeros. The main reason to merge two cliques is that they might overlap a lot and therefore it is not advantageous to treat them as two different blocks. Consider the two extreme cases below:</p><p><img src="../assets/extrem_case1.jpg" alt/> <img src="../assets/extrem_case2.jpg" alt/></p><p>In the left figure we have the ideal case that all the blocks overlap in just one entry. A full decomposition would leave us with a large number of small blocks. The sparsity pattern in the right figure has two large blocks overlapping almost entirely. In this case it would be disadvantageous to decompose the blocks. Instead, we would do the initial decomposition, realize the large overlap, and then merge the two blocks back together. For sparsity patterns that arise from real applications the case is not always as clear and we have to use more sophisticated strategies to decide which blocks to merge.</p><p><code>COSMO</code> currently provides three different strategies that can be selected by the user:</p><article class="docstring"><header><a class="docstring-binding" id="COSMO.NoMerge" href="#COSMO.NoMerge"><code>COSMO.NoMerge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoMerge &lt;: AbstractMergeStrategy</code></pre><p>A strategy that does not merge cliques.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oxfordcontrol/COSMO.jl/blob/d03d34012ab82d4abebd08f7a10807b7d9761ad2/src/chordal_decomposition/clique_merging.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COSMO.ParentChildMerge" href="#COSMO.ParentChildMerge"><code>COSMO.ParentChildMerge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParentChildMerge(t_fill = 8, t_size = 8) &lt;: AbstractTreeBasedMerge</code></pre><p>The merge strategy suggested in <em>Sun and Andersen - Decomposition in conic optimization with partially separable structure (2014)</em>. The initial clique tree is traversed in topological order and a clique <span>$\mathcal{C}_\ell$</span>  is greedily merged to its parent clique <span>$\mathcal{C}_{par(\ell)}$</span> if at least one of the two conditions are met</p><ul><li><span>$(| \mathcal{C}_{par(\ell)}| -| \eta_\ell|) (|\mathcal{C}_\ell| - |\eta_\ell|) \leq t_{\text{fill}}$</span> (fill-in condition)</li><li><span>$\max \left\{ |\nu_{\ell}|,  |\nu_{par(\ell)}|  \right\} \leq t_{\text{size}}$</span> (supernode size condition)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oxfordcontrol/COSMO.jl/blob/d03d34012ab82d4abebd08f7a10807b7d9761ad2/src/chordal_decomposition/clique_merging.jl#L73-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COSMO.CliqueGraphMerge" href="#COSMO.CliqueGraphMerge"><code>COSMO.CliqueGraphMerge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CliqueGraphMerge(edge_weight::AbstractEdgeWeight = ComplexityWeight()) &lt;: AbstractGraphBasedMerge</code></pre><p>The (default) merge strategy based on the <em>reduced</em> clique graph <span>$\mathcal{G}(\mathcal{B}, \xi)$</span>, for a set of cliques <span>$\mathcal{B} = \{ \mathcal{C}_1, \dots, \mathcal{C}_p\}$</span> where the edge set <span>$\xi$</span> is obtained by taking the edges of the union of clique trees.</p><p>Moreover, given an edge weighting function <span>$e(\mathcal{C}_i,\mathcal{C}_j) = w_{ij}$</span>, we compute a weight for each edge that quantifies the computational savings of merging the two cliques. After the initial weights are computed, we merge cliques in a loop:</p><p><strong>while</strong> clique graph contains positive weights:</p><ul><li>select two permissible cliques with the highest weight <span>$w_{ij}$</span></li><li>merge cliques <span>$\rightarrow$</span> update clique graph</li><li>recompute weights for updated clique graph</li></ul><p>Custom edge weighting functions can be used by defining your own <code>CustomEdgeWeight &lt;: AbstractEdgeWeight</code> and a corresponding <code>edge_metric</code> method. By default, the <code>ComplexityWeight &lt;: AbstractEdgeWeight</code> is used which computes the weight based on the cardinalities of the cliques: <span>$e(\mathcal{C}_i,\mathcal{C}_j)  = |\mathcal{C}_i|^3 + |\mathcal{C}_j|^3 - |\mathcal{C}_i \cup \mathcal{C}_j|^3$</span>.</p><p>See also: <em>Garstka, Cannon, Goulart - A clique graph based merging strategy for decomposable SDPs (2019)</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oxfordcontrol/COSMO.jl/blob/d03d34012ab82d4abebd08f7a10807b7d9761ad2/src/chordal_decomposition/clique_merging.jl#L42-L59">source</a></section></article><p>In our example problem we have two cliques <span>$\mathcal{C}_3 = \{ 3,6,7,8\}$</span> and <span>$\mathcal{C}_5 = \{6,7,8,9 \}$</span> that overlap in three entries. Let&#39;s solve the problem again and choose the default clique merging strategy <code>merge_strategy = COSMO.CliqueGraphMerge</code>:</p><pre><code class="language-julia hljs">model = JuMP.Model(with_optimizer(COSMO.Optimizer, decompose = true, merge_strategy = COSMO.CliqueGraphMerge));
@variable(model, x[1:2]);
@objective(model, Min, c&#39; * x )
@constraint(model, Symmetric(B - A1  .* x[1] - A2 .* x[2] )  in JuMP.PSDCone());

JuMP.optimize!(model)</code></pre><pre><code class="language-julia hljs">------------------------------------------------------------------
          COSMO v0.5.0 - A Quadratic Objective Conic Solver
                         Michael Garstka
                University of Oxford, 2017 - 2019
------------------------------------------------------------------

Problem:  x ∈ R^{7},
          constraints: A ∈ R^{30x7} (58 nnz),
          matrix size to factor: 37x37 (153 nnz)
Sets:     PsdConeTriangle of dim: 15
          PsdConeTriangle of dim: 6
          PsdConeTriangle of dim: 6
          PsdConeTriangle of dim: 3
Decomp:   Num of original PSD cones: 1
          Num decomposable PSD cones: 1
          Num PSD cones after decomposition: 4
          Merge Strategy: CliqueGraphMerge
Settings: ϵ_abs = 1.0e-04, ϵ_rel = 1.0e-04,
          ϵ_prim_inf = 1.0e-06, ϵ_dual_inf = 1.0e-04,
          ρ = 0.1, σ = 1.0e-6, α = 1.6,
          max_iter = 2500,
          scaling iter = 10 (on),
          check termination every 40 iter,
          check infeasibility every 40 iter,
          KKT system solver: QDLDL
Setup Time: 0.26ms

Iter:   Objective:  Primal Res: Dual Res:   Rho:
40  -1.4134e+00 1.7924e-05  1.0416e-04  1.0000e-01

------------------------------------------------------------------
&gt;&gt;&gt; Results
Status: Solved
Iterations: 40
Optimal objective: -1.4134
Runtime: 0.003s (2.68ms)</code></pre><p>Unsurprisingly, we can see in the output that <code>COSMO</code> solved a problem with four PSD constraints. One of them is of dimension 15, i.e. a <span>$5\times 5$</span> block, which correspond to the merged clique <span>$\mathcal{C_3} \cup \mathcal{C}_5 = \{3,6,7,8,9 \}$</span>.</p><h2 id="Completing-the-dual-variable"><a class="docs-heading-anchor" href="#Completing-the-dual-variable">Completing the dual variable</a><a id="Completing-the-dual-variable-1"></a><a class="docs-heading-anchor-permalink" href="#Completing-the-dual-variable" title="Permalink"></a></h2><p>After a decomposed problem is solved, we can recover the solution to the original problem by assembling the matrix variable <span>$S$</span> from its subblocks <span>$S_\ell$</span>:</p><p class="math-container">\[S = \displaystyle \sum_{\ell = 1}^p T_\ell^\top S_\ell T_\ell,\]</p><p>Following Agler&#39;s Theorem, <span>$S$</span> will be a positive semidefinite matrix. However, this is not true for the corresponding dual variable matrix <span>$Y$</span>.  The dual variable returned after solving the decomposed problem will be in the space of PSD completable matrices <span>$Y \in \mathbb{S}_+^n(E,?)$</span>. This means that the entries in <span>$Y$</span> corresponding to the blocks <span>$S_\ell$</span> (black dots) have been chosen correctly. The numerical values for all the other entries (corresponding to the zeros in <span>$S$</span> and denoted with a red dot) have to be chosen in the right way to make <span>$Y$</span> positive semidefinite.</p><p><img src="../assets/psd_completion.jpg" alt/></p><p>For more information about PSD matrix completion and the completion algorithm used in <code>COSMO</code> take a look at <em>Vandenberghe and Andersen - Chordal Graphs and Semidefinite Optimization</em> (Ch.10). To configure <code>COSMO</code> to complete the dual variable after solving the problem you have to set the <code>complete_dual</code> option:</p><pre><code class="language-julia hljs">model = JuMP.Model(with_optimizer(COSMO.Optimizer, complete_dual = true));</code></pre><h3 id="Example-Code"><a class="docs-heading-anchor" href="#Example-Code">Example Code</a><a id="Example-Code-1"></a><a class="docs-heading-anchor-permalink" href="#Example-Code" title="Permalink"></a></h3><p>The code used for this example can be found in <a href="https://github.com/oxfordcontrol/COSMO.jl/tree/master/examples/chordal_decomposition.jl">/examples/chordal_decomposition.jl</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../literate/build/custom_cone/">« Custom Cone Constraint</a><a class="docs-footer-nextpage" href="../literate/build/portfolio_model_updates/">Model Updates »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Sunday 23 July 2023 16:18">Sunday 23 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
